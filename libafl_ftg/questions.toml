[[question]]
id = "intro"
title = "Introduction"
content = """\
Description\n
New line\
"""
answers = [ "Next" ]
next = [ "source code" ]
code = []
previous = 0
skip = false

[[question]]
id = "source code"
title = "Do you have the target's source code?"
content = "Description"
answers = [ "Yes", "No" ]
next = [ "harness", "observers" ]
code = []
previous = 0
skip = false

[[question]]
id = "harness"
title = "Can you provide a harness function?"
content = "Description"
answers = [ "Yes", "No" ]
next = [ "observers", "observers" ]
code = []
previous = 0
skip = false

[[question]]
id = "observers"
title = "Observers"
content = "Description"
answers = [ "Next" ]
next = [ "map size" ]
code = []
previous = 0
skip = false

[[question]]
id = "map size"
title = "Do you know the size of the map at compile time?"
content = "Description"
answers = [ "Yes", "No" ]
next = [ "hit counts", "hit counts" ]
code = [ "let observer = ConstMapObserver::<>::new()", "let observer = StdMapObserver::new()" ]
previous = 0
skip = false

[[question]]
id = "hit counts"
title = "Do you want to improve input selection by adding a hit counts map?"
content = "Description"
answers = [ "Yes", "No" ]
next = [ "feedback", "feedback" ]
code = [ "let observer = HitcountsMapObserver::new($)", "" ]
previous = 0
skip = false

[[question]]
id = "feedback"
title = "Feedback"
content = "Description"
answers = [ "Next" ]
next = [ "runtime" ]
code = []
previous = 0
skip = false

[[question]]
id = "runtime"
title = "Do you want to keep track of the testcase's runtime?"
content = "Description"
answers = [ "Yes", "No" ]
next = [ "crash", "crash" ]
code = [ "let mut feedback =  feedback_or!(MaxMapFeedback::new(&observer), TimeObserver::new())", "let mut feedback =  MaxMapFeedback::new(&observer)" ]
previous = 0
skip = false

[[question]]
id = "crash"
title = "Do you want to consider a crash as a solution?"
content = "Description"
answers = [ "Yes", "No" ]
next = [ "timeout", "state" ]
code = [ "let mut objective = CrashFeedback::new()", "let mut objective = TimeoutFeedback::new()" ]
previous = 0
skip = false

[[question]]
id = "timeout"
title = "Do you want to consider a timeout as a solution?"
content = "Description"
answers = [ "Yes", "No" ]
next = [ "state", "state" ]
code = [ "let mut objective = feedback_and!($, TimeoutFeedback::new())", "" ]
previous = 0
skip = false

[[question]]
id = "state"
title = "State/Corpus"
content = "Description"
answers = [ "Next" ]
next = [ "manage testcases" ]
code = []
previous = 0
skip = false

[[question]]
id = "manage testcases"
title = "Do you want to manage the testcases in memory, on disk or both?"
content = "Description"
answers = [ "On disk", "In memory", "Both" ]
next = [ "via cache", "load state", "load state" ]
code = [ "", "InMemoryCorpus::new()", "InMemoryOnDiskCorpus::new().unwrap()" ]
previous = 0
skip = false

[[question]]
id = "via cache"
title = "Do you want to load testcases from disk to memory using a cache?"
content = "Description"
answers = [ "Yes", "No" ]
next = [ "load state", "load state" ]
code = [ "CachedOnDiskCorpus::new().unwrap()", "OnDiskCorpus::new().unwrap()" ]
previous = 0
skip = false

[[question]]
id = "load state"
title = ""
content = ""
answers = [ "" ]
next = [ "monitors" ]
code = [ "let mut state = StdState::new(StdRand::with_seed(current_nanos()), $, OnDiskCorpus::new(PathBuf::from()).unwrap(), &mut feedback, &mut objective,).unwrap()" ]
previous = 0
skip = false

[[question]]
id = "monitors"
title = "Monitors"
content = "Description"
answers = [ "Next" ]
next = [ "stats" ]
code = []
previous = 0
skip = false

[[question]]
id = "stats"
title = "Do you want to see stats about the fuzzing campaign?"
content = "Description"
answers = [ "Yes", "No" ]
next = [ "stats in ui", "stats to file" ]
code = [ "", "let mon = NopMonitor::new()" ]
previous = 0
skip = false

[[question]]
id = "stats in ui"
title = "Do you want to see the stats in a UI style?"
content = "Description"
answers = [ "Yes", "No" ]
next = [ "stats to file", "stats to file" ]
code = [ "let mon = (WIP)", "let mon = SimpleMonitor::new()" ]
previous = 0
skip = false

[[question]]
id = "stats to file"
title = "Do you want to store the stats to a file too?"
content = "Description"
answers = [ "Yes", "No" ]
next = [ "file extensions", "events" ]
code = [ "", "" ]
previous = 0
skip = false

[[question]]
id = "file extensions"
title = "Do you want to store them to a TOML or JSON file?"
content = "Description"
answers = [ "TOML", "JSON" ]
next = [ "events", "events" ]
code = [ "let mon = OnDiskTOMLMonitor::new($)", "let mon = OnDiskJSONMonitor::new($)" ]
previous = 0
skip = false

[[question]]
id = "events"
title = "Events"
content = "Description"
answers = [ "Next" ]
next = [ "restart fuzzer" ]
code = []
previous = 0
skip = false

[[question]]
id = "restart fuzzer"
title = "Do you want to restart your fuzzer every time a solution is achieved?"
content = "Description"
answers = [ "Yes", "No" ]
next = [ "restart fuzzer llmp", "restart fuzzer llmp" ]
code = [ "let mut mgr = SimpleRestartingEventManager::launch(mon)", "let mut mgr = SimpleEventManager::new(mon)" ]
previous = 0
skip = false

[[question]]
id = "restart fuzzer llmp"
title = "Do you want to restart your fuzzer every time a solution is achieved (LLMP)?"
content = "Description"
answers = [ "Yes", "No" ]
next = [ "schedulers", "schedulers" ]
code = [ "let mut mgr = LlmpRestartingEventManager::new(mon)", "let mut mgr = LlmpEventManager::new(mon).unwrap()" ]
previous = 0
skip = false

[[question]]
id = "schedulers"
title = "Schedulers"
content = "Description"
answers = [ "Next" ]
next = [ "queue policy" ]
code = []
previous = 0
skip = false

[[question]]
id = "queue policy"
title = "Do you want to load testcases from the corpus using a queue policy?"
content = "Description"
answers = [ "Yes", "No" ]
next = [ "smaller and faster", "fuzzer" ]
code = [ "let scheduler = QueueScheduler::new()", "let scheduler = RandScheduler::new()" ]
previous = 0
skip = false

[[question]]
id = "smaller and faster"
title = "Do you want to prioritize smaller and faster testcases?"
content = "Description"
answers = [ "Yes", "No" ]
next = [ "fuzzer", "fuzzer" ]
code = [ "let scheduler = IndexesLenTimeMinimizerScheduler::new($)", "" ]
previous = 0
skip = false

[[question]]
id = "fuzzer"
title = "Fuzzer"
content = "Description"
answers = [ "Next" ]
next = [ "load fuzzer" ]
code = []
previous = 0
skip = false

[[question]]
id = "load fuzzer"
title = ""
content = ""
answers = [ "" ]
next = [ "executors" ]
code = ["let mut fuzzer = StdFuzzer::new(scheduler, feedback, objective)" ]
previous = 0
skip = false

[[question]]
id = "executors"
title = "Executors"
content = "Description"
answers = [ "Next" ]
next = [ "corrupt memory" ]
code = []
previous = 0
skip = false


[[question]]
id = "corrupt memory"
title = "Can your target corrupt memory used by the fuzzer?"
content = "Description"
answers = [ "Yes", "No" ]
next = [ "in process timeout", "in process timeout" ]
code = [ "let mut executor = InProcessForkExecutor::new()", "let mut executor = InProcessExecutor::new()" ]
previous = 0
skip = false

[[question]]
id = "in process timeout"
title = "Do you want to set a timeout before each run?"
content = "Description"
answers = [ "Yes", "No" ]
next = [ "forkserver timeout", "forkserver timeout" ]
code = [ "let mut executor = TimeoutExecutor::new($, Duration::from_secs())", "" ]
previous = 0
skip = false

[[question]]
id = "forkserver timeout"
title = "Do you want to set a timeout before each run (forkserver)?"
content = "Description"
answers = [ "Yes", "No" ]
next = [ "generators", "generators" ]
code = [ "let mut executor = TimeoutForkserverExecutor::new($, Duration::from_secs())", "let mut executor = ForkserverExecutor::new()" ]
previous = 0
skip = false

[[question]]
id = "generators"
title = "Generators"
content = "Description"
answers = [ "Next" ]
next = [ "initial inputs" ]
code = []
previous = 0
skip = false

[[question]]
id = "initial inputs"
title = "Do you want to generate an initial set of inputs?"
content = "Description"
answers = [ "Yes", "No" ]
next = [ "mutators", "mutators" ]
code = [ "let mut = RandBytesGenerator::new()", "" ]
previous = 0
skip = false

[[question]]
id = "mutators"
title = "Mutators"
content = "Description"
answers = [ "Next" ]
next = [ "schedule mutations" ]
code = []
previous = 0
skip = false

[[question]]
id = "schedule mutations"
title = "Do you want to schedule mutations?"
content = "Description"
answers = [ "Yes", "No" ]
next = [ "stages", "stages" ]
code = [ "let mutator = StdScheduledMutator::new()", "" ]
previous = 0
skip = false

[[question]]
id = "stages"
title = "Stages"
content = "Description"
answers = [ "Next" ]
next = [ "StdMutationalStage" ]
code = []
previous = 0
skip = false

[[question]]
id = "StdMutationalStage"
title = "Do you want to use the StdMutationalStage?"
content = "Description"
answers = [ "Yes", "No" ]
next = [ "end", "end" ]
code = [ "let mut stages = StdMutationalStage::new()", "" ]
previous = 0
skip = false

[[question]]
id = "end"
title = ""
content = ""
answers = []
next = []
code = []
previous = 0
skip = false