[[question]]
id = "intro"
title = "Introduction"
content = """
Description
New line
"""
answers = [ "Next" ]
next = [ "source code" ]
code = []
previous = 0
skip = false

[[question]]
id = "source code"
title = "Do you have the target's source code?"
content = "Description"
answers = [ "Yes", "No" ]
next = [ "harness", "observers" ]
code = [ "",
"""let mut shmem_provider = UnixShMemProvider::new().unwrap();\n
let mut shmem = shmem_provider.new_shmem(MAP_SIZE).unwrap();
shmem.write_to_env("__AFL_SHM_ID").unwrap();
let shmem_buf = shmem.as_mut_slice();""" ]
previous = 0
skip = false

[[question]]
id = "harness"
title = "Can you provide a harness function?"
content = "Description"
answers = [ "Yes", "No" ]
next = [ "observers", "observers" ]
code = [ "",
"""let mut shmem_provider = UnixShMemProvider::new().unwrap();\n
let mut shmem = shmem_provider.new_shmem(MAP_SIZE).unwrap();
shmem.write_to_env("__AFL_SHM_ID").unwrap();
let shmem_buf = shmem.as_mut_slice();""" ]
previous = 0
skip = false

[[question]]
id = "observers"
title = "Observers"
content = "Description"
answers = [ "Next" ]
next = [ "map size" ]
code = []
previous = 0
skip = false

[[question]]
id = "map size"
title = "Do you know the size of the map at compile time?"
content = "Description"
answers = [ "Yes", "No" ]
next = [ "hit counts", "hit counts" ]
code = [ "let observer = ConstMapObserver::<>::new()", "let observer = StdMapObserver::new()" ]
previous = 0
skip = false

[[question]]
id = "hit counts"
title = "Do you want to improve input selection by adding a hit counts map?"
content = "Description"
answers = [ "Yes", "No" ]
next = [ "feedback", "feedback" ]
code = [ "let observer = HitcountsMapObserver::new($)", "" ]
previous = 0
skip = false

[[question]]
id = "feedback"
title = "Feedback"
content = "Description"
answers = [ "Next" ]
next = [ "runtime" ]
code = []
previous = 0
skip = false

[[question]]
id = "runtime"
title = "Do you want to keep track of the testcase's runtime?"
content = "Description"
answers = [ "Yes", "No" ]
next = [ "crash", "crash" ]
code = [ """let mut feedback =  feedback_or!(
\tMaxMapFeedback::new(&observer),
\tTimeObserver::new()
)""",
"let mut feedback =  MaxMapFeedback::new(&observer)" ]
previous = 0
skip = false

[[question]]
id = "crash"
title = "Do you want to consider a crash as a solution?"
content = "Description"
answers = [ "Yes", "No" ]
next = [ "timeout", "state" ]
code = [ "let mut objective = CrashFeedback::new()", "let mut objective = TimeoutFeedback::new()" ]
previous = 0
skip = false

[[question]]
id = "timeout"
title = "Do you want to consider a timeout as a solution?"
content = "Description"
answers = [ "Yes", "No" ]
next = [ "state", "state" ]
code = [ "let mut objective = feedback_and!($, TimeoutFeedback::new())", "" ]
previous = 0
skip = false

[[question]]
id = "state"
title = "State/Corpus"
content = "Description"
answers = [ "Next" ]
next = [ "manage testcases" ]
code = []
previous = 0
skip = false

[[question]]
id = "manage testcases"
title = "Do you want to manage the testcases in memory, on disk or both?"
content = "Description"
answers = [ "On disk", "In memory", "Both" ]
next = [ "via cache", "load state", "load state" ]
code = [ "", "InMemoryCorpus::new()", "InMemoryOnDiskCorpus::new().unwrap()" ]
previous = 0
skip = false

[[question]]
id = "via cache"
title = "Do you want to load testcases from disk to memory using a cache?"
content = "Description"
answers = [ "Yes", "No" ]
next = [ "load state", "load state" ]
code = [ "CachedOnDiskCorpus::new().unwrap()", "OnDiskCorpus::new().unwrap()" ]
previous = 0
skip = false

[[question]]
id = "load state"
title = ""
content = ""
answers = [ "" ]
next = [ "monitors" ]
code = [ """let mut state = StdState::new(
\tStdRand::with_seed(current_nanos()),
\t$,
\tOnDiskCorpus::new(PathBuf::from("./crashes")).unwrap(),
\t&mut feedback,
\t&mut objective,
)
.unwrap()""" ]
previous = 0
skip = false

[[question]]
id = "monitors"
title = "Monitors"
content = "Description"
answers = [ "Next" ]
next = [ "stats" ]
code = []
previous = 0
skip = false

[[question]]
id = "stats"
title = "Do you want to see stats about the fuzzing campaign?"
content = "Description"
answers = [ "Yes", "No" ]
next = [ "stats in ui", "stats to file" ]
code = [ "", "let mon = NopMonitor::new()" ]
previous = 0
skip = false

[[question]]
id = "stats in ui"
title = "Do you want to see the stats in a UI style?"
content = "Description"
answers = [ "Yes", "No" ]
next = [ "stats to file", "stats to file" ]
code = [ "let mon = (WIP)", """let mon = SimpleMonitor::new(|s| println!("{s}")""" ]
previous = 0
skip = false

[[question]]
id = "stats to file"
title = "Do you want to store the stats to a file too?"
content = "Description"
answers = [ "Yes", "No" ]
next = [ "file extensions", "events" ]
code = [ "", "" ]
previous = 0
skip = false

[[question]]
id = "file extensions"
title = "Do you want to store them to a TOML or JSON file?"
content = "Description"
answers = [ "TOML", "JSON" ]
next = [ "events", "events" ]
code = [ "let mon = OnDiskTOMLMonitor::new($)", "let mon = OnDiskJSONMonitor::new($)" ]
previous = 0
skip = false

[[question]]
id = "events"
title = "Events"
content = "Description"
answers = [ "Next" ]
next = [ "restart fuzzer" ]
code = []
previous = 0
skip = false

[[question]]
id = "restart fuzzer"
title = "Do you want to restart your fuzzer every time a solution is achieved?"
content = "Description"
answers = [ "Yes", "No" ]
next = [ "restart fuzzer llmp", "restart fuzzer llmp" ]
code = [ "let mut mgr = SimpleRestartingEventManager::launch(mon)", "let mut mgr = SimpleEventManager::new(mon)" ]
previous = 0
skip = false

[[question]]
id = "restart fuzzer llmp"
title = "Do you want to restart your fuzzer every time a solution is achieved (LLMP)?"
content = "Description"
answers = [ "Yes", "No" ]
next = [ "schedulers", "schedulers" ]
code = [ "let mut mgr = LlmpRestartingEventManager::new(mon)", "let mut mgr = LlmpEventManager::new(mon).unwrap()" ]
previous = 0
skip = false

[[question]]
id = "schedulers"
title = "Schedulers"
content = "Description"
answers = [ "Next" ]
next = [ "queue policy" ]
code = []
previous = 0
skip = false

[[question]]
id = "queue policy"
title = "Do you want to load testcases from the corpus using a queue policy?"
content = "Description"
answers = [ "Yes", "No" ]
next = [ "smaller and faster", "fuzzer" ]
code = [ "let scheduler = QueueScheduler::new()", "let scheduler = RandScheduler::new()" ]
previous = 0
skip = false

[[question]]
id = "smaller and faster"
title = "Do you want to prioritize smaller and faster testcases?"
content = "Description"
answers = [ "Yes", "No" ]
next = [ "fuzzer", "fuzzer" ]
code = [ "let scheduler = IndexesLenTimeMinimizerScheduler::new($)", "" ]
previous = 0
skip = false

[[question]]
id = "fuzzer"
title = "Fuzzer"
content = "Description"
answers = [ "Next" ]
next = [ "load fuzzer" ]
code = []
previous = 0
skip = false

[[question]]
id = "load fuzzer"
title = ""
content = ""
answers = [ "" ]
next = [ "executors" ]
code = ["let mut fuzzer = StdFuzzer::new(scheduler, feedback, objective)" ]
previous = 0
skip = false

[[question]]
id = "executors"
title = "Executors"
content = "Description"
answers = [ "Next" ]
next = [ "corrupt memory" ]
code = []
previous = 0
skip = false


[[question]]
id = "corrupt memory"
title = "Can your target corrupt memory used by the fuzzer?"
content = "Description"
answers = [ "Yes", "No" ]
next = [ "in process timeout", "in process timeout" ]
code = [ """let mut shmem_provider = unix_shmem::UnixShMemProvider::new().unwrap();\n
let mut executor = InProcessForkExecutor::new(
\t&mut harness,
\ttuple_list!(observer),
\t&mut fuzzer,
\t&mut state,
\t&mut mgr,
\tshmem_provider
)
.expect("Failed to create the Executor")""",
"""let mut executor = InProcessExecutor::new(
\t&mut harness,
\ttuple_list!(observer),
\t&mut fuzzer,
\t&mut state,
\t&mut mgr,
)\
.expect("Failed to create the Executor")""" 
]
previous = 0
skip = false

[[question]]
id = "in process timeout"
title = "Do you want to set a timeout before each run?"
content = "Description"
answers = [ "Yes", "No" ]
next = [ "forkserver timeout", "forkserver timeout" ]
code = [ """let mut executor = TimeoutExecutor::new(
$,
Duration::from_secs()
)""",
"" ]
previous = 0
skip = false

[[question]]
id = "forkserver timeout"
title = "Do you want to set a timeout before each run (forkserver)?"
content = "Description"
answers = [ "Yes", "No" ]
next = [ "generators", "generators" ]
code = [ """let mut executor = TimeoutForkserverExecutor::new(
\t$,
\tDuration::from_secs()
)""",
"let mut executor = ForkserverExecutor::new()" ]
previous = 0
skip = false

[[question]]
id = "generators"
title = "Generators"
content = "Description"
answers = [ "Next" ]
next = [ "initial inputs" ]
code = []
previous = 0
skip = false

[[question]]
id = "initial inputs"
title = "Do you want to generate an initial set of inputs?"
content = "Description"
answers = [ "Yes", "No" ]
next = [ "mutators", "mutators" ]
code = [ """let mut generator = RandBytesGenerator::new(32);\n
state
\t.generate_initial_inputs(&mut fuzzer, &mut executor, &mut generator, &mut mgr, 8)
\t.expect("Failed to generate the initial corpus")"""
, "" ]
previous = 0
skip = false

[[question]]
id = "mutators"
title = "Mutators"
content = "Description"
answers = [ "Next" ]
next = [ "schedule mutations" ]
code = []
previous = 0
skip = false

[[question]]
id = "schedule mutations"
title = "Do you want to schedule mutations?"
content = "Description"
answers = [ "Yes", "No" ]
next = [ "stages", "stages" ]
code = [ "let mutator = StdScheduledMutator::new(havoc_mutations())", "" ]
previous = 0
skip = false

[[question]]
id = "stages"
title = "Stages"
content = "Description"
answers = [ "Next" ]
next = [ "StdMutationalStage" ]
code = []
previous = 0
skip = false

[[question]]
id = "StdMutationalStage"
title = "Do you want to use the StdMutationalStage?"
content = "Description"
answers = [ "Yes", "No" ]
next = [ "fuzz loop", "fuzz loop" ]
code = [ "let mut stages = tuple_list!(StdMutationalStage::new())", "" ]
previous = 0
skip = false

[[question]]
id = "fuzz loop"
title = ""
content = ""
answers = [ "" ]
next = [ "end" ]
code = [ """fuzzer
\t.fuzz_loop(&mut stages, &mut executor, &mut state, &mut mgr)
\t.expect("Error in the fuzzing loop")""" ]
previous = 0
skip = false

[[question]]
id = "end"
title = ""
content = ""
answers = []
next = []
code = []
previous = 0
skip = false