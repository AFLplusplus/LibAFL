[[question]]
id = "intro"
title = "libafl_wizard: a tool to generate Libafl-based fuzzers."
content = """
Before starting, make sure that you know your target very well. Choosing the right components to build a fuzzer depends on the details of the
implementation of your target.

Knowing what you want before building a fuzzer can be extremely helpful when selecting the components that best fit your options and the
restrictions of the environment.

Details such as:
    *Having the source code of the target.
    *Implementing a harness function to fuzz your target.
    *Knowing the expected input by the target.
    *Providing an initial set of inputs.
    *The size of the target and the availability of memory.
    *The possibility of memory corruption.

Can be helpful during this process.
"""
answers = [ "Next" ]
next = [ "source code" ]
code = []
skip = []
skipped_by = ""
previous = "intro"

[[question]]
id = "source code"
title = "Do you have the target's source code?"
content = """
Having the target's source code is interesting for performance. With the source code in hands, we can instrument the target, that is,
place coverage information to help our fuzzer identify new points of execution.

Without instrumentation on the source, we have to rely on third-party applications to provide this infromation for our fuzzer,
such as QEMU, FRIDA or Tiny Inst. Note that QEMU only supports Linux.
"""
answers = [ "Yes", "No" ]
next = [ "harness", "END" ]
code = []
skip = []
skipped_by = ""
previous = ""

[[question]]
id = "harness"
title = "Can you provide a harness function?"
content = """
Providing a harness also has an impact on performance, for it allows in-process fuzzing.
"""
answers = [ "Yes", "No" ]
next = [ "special algorithm" ]
code = [ 
"""
""",
"""
const MAP_SIZE: usize = 65536;

let mut shmem = shmem_provider.new_shmem(MAP_SIZE).unwrap();
shmem.write_to_env("__AFL_SHM_ID").unwrap();
let shmem_buf = shmem.as_mut_slice();
""" ]
skip = []
skipped_by = ""
previous = ""

[[question]]
id = "special algorithm"
title = "Do you want to use some special algorithm to select and update testcases from the corpus?"
content = """
Usually, a testcase that reaches a new execution point or achieves the desired objective, e.g. a crash on the target, are deemed interesting,
stored for later use and then selected using a determined policy. However, we can select which testcases to use based on variable aspects: for
instance, we can prioritize testacases that are smaller in size and take less time to execute (following a minimization policy).

There are many algorithms supported by Libafl to choose, for more information, please read the libafl documentation on Schedulers and Stages.
"""
answers = [ "Yes", "No" ]
next = [ "algorithm options", "special input" ]
code = [ 
"""
""",
"""
let scheduler = QueueScheduler::new();

let mut stages = tuple_list!(StdMutationalStage::new(mutator));
""" ]
skip = []
skipped_by = ""
previous = ""

[[question]]
id = "algorithm options"
title = "Which of the following options would you like to use?"
content = """
(maybe give a quick explanation about each?)
"""
answers = [ "Accounting", "Ecofuzz", "Minimizer", "Power Scheduling", "Probabilistic Sampling", "Weighted" ]
next = [ "special input" ]
code = [ 
"""
let scheduler = CoverageAccountingScheduler::new(&mut state, QueueScheduler::new(), unsafe {
    &ACCOUNTING_MEMOP_MAP
    });

let mut stages = tuple_list!(StdMutationalStage::new(mutator));
""",
"""
let scheduler = EcoScheduler:new(&mut state, &observer);

let mut stages = tuple_list!(StdMutationalStage::new(mutator));
""",
"""
let scheduler = IndexesLenTimeMinimizerScheduler::new(QueueScheduler::new());

let mut stages = tuple_list!(StdMutationalStage::new(mutator));
""",
"""
let scheduler = PowerQueueScheduler::new(
    &mut state,
    &observer,
    PowerSchedule::FAST,
);

let mut stages = tuple_list!(PowerMutationalStage::new(mutator));
""",
"""
let scheduler = ProbabilitySamplingScheduler::new();

let mut stages = tuple_list!(StdMutationalStage::new(mutator));
""",
"""
let time_observer = TimeObserver::new("time");

let scheduler = StdWeightedScheduler::with_schedule(
    &mut state,
    &observer,
    Some(PowerSchedule::FAST),
);

let calibration = CalibrationStage::new(&map_feedback);

let power = StdPowerMutationalStage::new(mutator);

let mut stages = tuple_list!(calibration, power);
""" ]
skip = []
skipped_by = ""
previous = ""

[[question]]
id = "special input"
title = "Does your target require some special type of input?"
content = """
Usually, libafl uses a map of bytes (BytesInput) to represent the input sent to the target for execution. (maybe cite some examples of data that can be represented as a map of bytes?)

More abstract or complex inputs, such as Grammar-Based have their own type in libafl. There are many input representations supported by Libafl
to choose, for more information about each, please read the libafl documentation on Inputs.
"""
answers = [ "Yes", "No" ]
next = [ "input options", "crash/timeout" ]
code = [ 
"""
""",
"""
let mutator = StdScheduledMutator::new(havoc_mutations());
""" ]
skip = []
skipped_by = ""
previous = ""

[[question]]
id = "input options"
title = "How can your input be represented?"
content = """
(again, maybe give a quick explanation about each?)
"""
answers = [ "Encoded", "Grimoire", "Gramatron", "Nautilus" ]
next = [ "crash/timeout" ]
code = [ 
"""
let mutator = StdScheduledMutator::with_max_stack_pow(encoded_mutations(), 2);
""",
"""
let generalization = GeneralizationStage::new(&observer);

let mutator = StdScheduledMutator::with_max_stack_pow(havoc_mutations(), 2);

let grimoire_mutator = StdScheduledMutator::with_max_stack_pow(
    tuple_list!(
      GrimoireExtensionMutator::new(),
      GrimoireRecursiveReplacementMutator::new(),
      GrimoireStringReplacementMutator::new(),
      GrimoireRandomDeleteMutator::new(),
      GrimoireRandomDeleteMutator::new(),
    ),
    3,
);

let mut stages = tuple_list!(
    generalization,
    StdMutationalStage::new(mutator),
    StdMutationalStage::transforming(grimoire_mutator)
);
""",
"""
let mutator = StdScheduledMutator::with_max_stack_pow(
    tuple_list!(
      GramatronRandomMutator::new(&generator),
      GramatronRandomMutator::new(&generator),
      GramatronRandomMutator::new(&generator),
      GramatronSpliceMutator::new(),
      GramatronSpliceMutator::new(),
      GramatronRecursionMutator::new()
    ),
    2,
);
""",
"""
let mutator = StdScheduledMutator::with_max_stack_pow(
        tuple_list!(
            GramatronRandomMutator::new(&generator),
            GramatronRandomMutator::new(&generator),
            GramatronRandomMutator::new(&generator),
            GramatronSpliceMutator::new(),
            GramatronSpliceMutator::new(),
            GramatronRecursionMutator::new()
        ),
        2,
    );
""" ]
skip = []
skipped_by = ""
previous = ""

[[question]]
id = "crash/timeout"
title = "Do you expect to cause a crash and/or a timeout on the target?"
content = """
Determining the objective of the fuzzing campaign is essential to identify input that triggered critical errors on the target.

Telling the fuzzer that we are looking for a crash means that a testcase, which causes a crash on the target, fullfills the objective and, differently from the ones
that e.g. reach a new execution point, this testcase is saved in a separate folder for you to check the input that trigerred the crash.

A timeout follows the same idea: a testcase that takes longer to execute than the defined timeout.

It's even possible to join these two ideas to instruct the fuzzzer that any testcase, which causes a crash or takes long enough to execute, is stored.

(I think that by crash, the fuzzer can catch the signal that finished the program and by timeout we are able to catch infinite recursion?)
"""
answers = [ "Crash or Timeout", "Crash", "Timeout" ]
next = [ "corrupt" ]
code = [ 
"""
let mut objective = feedback_or_fast!(
    CrashFeedback::new(),
    TimeoutFeedback::new()
);
""",
"""
let mut objective = CrashFeedback::new();
""",
"""
let mut objective = TimeoutFeedback::new();
""" ]
skip = []
skipped_by = ""
previous = ""

[[question]]
id = "corrupt"
title = "Can your target corrupt memory used by the fuzzer?"
content = """
Under some circumstances, you may find your harness pretty unstable or your harness wreaks havoc on the global states.
In this case, you want to fork it before executing the harness runs in the child process so that it doesn't break things.
(from the book for now hahahaha)
"""
answers = [ "Yes", "No" ]
next = [ "END", "END" ]
code = [ 
"""
let mut executor = InProcessForkExecutor::new(
        &mut harness,
        tuple_list!(observer),
        &mut fuzzer,
        &mut state,
        &mut mgr,
        shmem_provider,
    )
    .expect("Failed to create the Executor");
""",
"""
let mut executor = InProcessExecutor::new(
        &mut harness,
        tuple_list!(observer),
        &mut fuzzer,
        &mut state,
        &mut mgr,
    )
    .expect("Failed to create the Executor");
""" ]
skip = []
skipped_by = ""
previous = ""

[[question]]
id = "END"
title = "All questions answered!"
content = """
YOU CAN CLOSE THIS WINDOW NOW
"""
answers = []
next = [ ]
code = []
skip = []
skipped_by = ""
previous = ""