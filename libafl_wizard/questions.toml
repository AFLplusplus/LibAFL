[[question]]
id = "intro"
title = "libafl_wizard: a tool to generate fuzzers using Libafl's components."
content = """
Before starting, make sure that you know your target very well. Choosing the right components to build a fuzzer depends on the details 
of  the implementation of your target.

Knowing what you want before building a fuzzer can be extremely helpful when selecting the components that best fit your options and 
the restrictions of the environment.

Details such as:
    *Having the source code of the target.
    *Implementing a harness function to fuzz your target.
    *Knowing the expected input by the target.
    *Providing an initial set of inputs.
    *The size of the target and the availability of memory.
    *The possibility of memory corruption.

Can be helpful during this process.
"""
skipped_by = ""
previous = "intro"

    [[question.answers]]
    was_chosen = false
    answer = "Next"
    next = "source code"
    code = ""
    skip = []

[[question]]
id = "source code"
title = "Do you have the target's source code?"
content = """
Having the target's source code is interesting for performance. With the source code in hands, we can instrument the target, that is,
place coverage information to help our fuzzer identify new points of execution (guide itself).

Without instrumentation on the source code, we have to rely on third-party applications to provide this information for our fuzzer,
such as QEMU, FRIDA or Tiny Inst.
"""
skipped_by = ""
previous = ""

    [[question.answers]]
    was_chosen = false
    answer = "Yes"
    next = "harness"
    code = ""
    skip = []

    [[question.answers]]
    was_chosen = false
    answer = "No"
    next = "END"
    code = ""
    skip = []

[[question]]
id = "harness"
title = "Can you provide a harness function?"
content = """
A harness function bridges the gap between how the fuzzer expects input to occur and how it's delivered. Essentially, the harness will 
receive the input (properly structured) and call the target/function under test with it. This allows for in-process fuzzing (when the 
harness is executed inside the fuzzer process), which increases performance a lot.

Not providing a harness makes in-process fuzzing impractical. Therefore, the only option left is to fork before executing the target,
which makes use of a shared memory region to record the coverage information.
"""
skipped_by = ""
previous = ""

    [[question.answers]]
    was_chosen = false
    answer = "Yes"
    next = "corrupt memory"
    code = ""
    skip = []

    [[question.answers]]
    was_chosen = false
    answer = "No"
    next = "crash/timeout"
    code = """
    /* Forkserver Executor */
    """
    skip = []

[[question]]
id = "corrupt memory"
title = "Can your target corrupt memory used by the fuzzer?"
content = """
Under some circumstances, you may find your harness pretty unstable or your harness wreaks havoc on the global states. In this case,
you want to fork it before executing the harness runs in the child process so that it doesn't break things.
"""
skipped_by = ""
previous = ""

    [[question.answers]]
    was_chosen = false
    answer = "Yes"
    next = "crash/timeout"
    code = """
    let mut shmem_provider = unix_shmem::UnixShMemProvider::new().unwrap();

    let mut executor = InProcessForkExecutor::new(
        &mut harness,
        tuple_list!(observer),
        &mut fuzzer,
        &mut state,
        &mut mgr,
        shmem_provider,
    )
    .expect("Failed to create the Executor");
    """
    skip = []

    [[question.answers]]
    was_chosen = false
    answer = "No"
    next = "crash/timeout"
    code = """
    let mut executor = InProcessExecutor::new(
        &mut harness,
        tuple_list!(observer),
        &mut fuzzer,
        &mut state,
        &mut mgr,
    )
    .expect("Failed to create the Executor");
    """
    skip = []

[[question]]
id = "crash/timeout"
title = "Do you expect to cause a crash or a timeout on the target?"
content = """
Determining the objective of the fuzzing campaign is essential to identify input that triggered critical errors on the target.

Telling the fuzzer that we are looking for a crash means that a testcase, which causes a crash on the target, fullfills the objective 
and, differently from the ones that e.g. reach a new execution point, this testcase is saved in a separate folder for you to check the 
input that trigerred the crash.

A timeout follows the same idea: a testcase that takes longer to execute than a particular timeout.

It's even possible to join these two ideas to instruct the fuzzzer that any testcase, which causes a crash or takes long enough to 
execute, is stored.
"""
skipped_by = ""
previous = ""

    [[question.answers]]
    was_chosen = false
    answer = "Crash"
    next = "default components"
    code = """
    let mut objective = CrashFeedback::new();
    """
    skip = []

    [[question.answers]]
    was_chosen = false
    answer = "Crash or Timeout"
    next = "default components"
    code = """
    let mut objective = feedback_or_fast!(
        CrashFeedback::new(),
        TimeoutFeedback::new()
    );
    """
    skip = []

    [[question.answers]]
    was_chosen = false
    answer = "Timeout"
    next = "default components"
    code = """
    let mut objective = TimeoutFeedback::new();
    """
    skip = []

[[question]]
id = "default components"
title = "TODO: create questions to choose between these components."
content = """
"""
skipped_by = ""
previous = ""

    [[question.answers]]
    was_chosen = false
    answer = "Next"
    next = "END"
    code = """
    let mut feedback = MaxMapFeedback::new(&observer);

    let mut state = StdState::new(
        StdRand::with_seed(current_nanos()),
        InMemoryCorpus::new(),
        OnDiskCorpus::new(PathBuf::from("./crashes")).unwrap(),
        &mut feedback,
        &mut objective,
    )
    .unwrap();

    let mon = SimpleMonitor::new(|s| println!("{s}"));

    let mut mgr = SimpleEventManager::new(mon);

    let scheduler = QueueScheduler::new();

    let mut fuzzer = StdFuzzer::new(scheduler, feedback, objective);

    let mutator = StdScheduledMutator::new(havoc_mutations());

    let mut stages = tuple_list!(StdMutationalStage::new(mutator));

    fuzzer
        .fuzz_loop(&mut stages, &mut executor, &mut state, &mut mgr)
        .expect("Error in the fuzzing loop");
    """
    skip = []

[[question]]
id = "END"
title = "All questions answered!"
content = ""
skipped_by = ""
previous = ""

    [[question.answers]]
    was_chosen = false
    answer = ""
    next = ""
    code = ""
    skip = []