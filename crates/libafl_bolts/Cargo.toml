[package]
name = "libafl_bolts"
version.workspace = true
authors = [
  "Andrea Fioraldi <andreafioraldi@gmail.com>",
  "Dominik Maier <domenukk@gmail.com>",
]
description = "Low-level bolts to create fuzzers and so much more"
documentation = "https://docs.rs/libafl"
repository = "https://github.com/AFLplusplus/LibAFL/"
readme = "./README.md"
license = "MIT OR Apache-2.0"
keywords = ["fuzzing", "testing", "security"]
edition = "2024"
rust-version = "1.87"
categories = [
  "development-tools::testing",
  "emulators",
  "embedded",
  "os",
  "no-std",
]

[package.metadata.docs.rs]
features = ["document-features"]
all-features = true

[features]
default = [
  "alloc",
  "derive",
  "gzip",
  "rand_trait",
  "serdeany_autoreg",
  "std",
  "xxh3",
]
document-features = ["dep:document-features"]

#! # Feature Flags
#! ### General Features

## Enables features that need rust's `std` lib to work, like print, env, ... support
std = [
  "alloc",
  "backtrace",
  "fast_rands/std",
  "hostname",
  "libafl_core/nix",
  "libafl_core/nix",
  "libafl_core/std",
  "libafl_core/std",
  "ll_mp/std",
  "nix",
  "no_std_time/std",
  "serde/std",
  "serial_test",
  "shmem_providers/std",
  "simd",
  "uds",
  "uds",
  "uuid",
  "uuid",
]

## Enables all features that allocate in `no_std`
alloc = [
  "ahash",
  "erased-serde/alloc",
  "fast_rands/alloc",
  "hashbrown",
  "libafl_core/alloc",
  "ll_mp/alloc",
  "no_std_time/alloc",
  "postcard",
  "serde/alloc",
  "shmem_providers/alloc",
  "tuple_list_ex/alloc",
]

## Provide the `#[derive(SerdeAny)]` macro.
derive = ["libafl_derive"]

## If set, libafl_bolt's `rand` implementations will implement `rand_core::CoreRng`
## and, inversely, all seedable `rand_core::RngCore` types can be used as Rng for LibAFL.
rand_trait = ["fast_rands/rand_trait"]

## Will build the `pyo3` bindings
python = ["pyo3", "std", "libafl_core/python"]

## Expose `libafl::prelude` for direct access to all types without additional `use` directives
prelude = []

## Expose `libafl_bolts::cli` for easy commandline parsing of common fuzzer settings
cli = ["clap"]

## Enables extra commandline flags for qemu-based fuzzers in `cli`
qemu_cli = ["cli"]

## Enables extra commandline flags for frida-based fuzzers in `cli`
frida_cli = ["cli"]

## Stores the backtraces of all generated `Error`s. Good for debugging, but may come with a slight performance hit.
errors_backtrace = ["libafl_core/errors_backtrace"]

## Enables gzip compression in certain parts of the lib
gzip = ["miniz_oxide", "alloc", "ll_mp/gzip"]

## Replaces `ahash` with the potentially faster [`xxh3`](https://github.com/Cyan4973/xxHash) in some parts of the lib.
## This yields a stable and fast hash, but may increase the resulting binary size slightly
## This also enables certain hashing and rand features in `no_std` no-alloc.
xxh3 = ["xxhash-rust"]

#! ### SerdeAny features

## With this feature, the AnyMap uses [`type_name`](https://doc.rust-lang.org/std/any/fn.type_name.html)
## instead of [`TypeId::of`](https://doc.rust-lang.org/std/any/struct.TypeId.html#method.of) for deserialization.
## With this feature, stored state remains deserializable across multiple compilations of LibAFL.
## The rust doc specifically states that "multiple types may map to the same type name", so it could potentially lead to bugs.
## However, we make sure that no two types with the same name ever exist.
stable_anymap = ["serde_anymap/stable_anymap"]

## Automatically register all `#[derive(SerdeAny)]` types at startup.
serdeany_autoreg = ["serde_anymap/serdeany_autoreg"]

#! ### LLMP features

## If set, llmp will bind to 0.0.0.0, allowing cross-device communication. Binds to localhost by default.
llmp_bind_public = ["ll_mp/llmp_bind_public"]

## Enables llmp compression using GZip
llmp_compression = ["ll_mp/llmp_compression"]

## Enables debug output for LLMP (also needs a `logger` installed)
llmp_debug = ["ll_mp/llmp_debug"]

## Reduces the initial map size for llmp
llmp_small_maps = ["ll_mp/llmp_small_maps"]

#! ### Stable SIMD features

## Use the best SIMD implementation by our benchmark.
simd = ["alloc", "wide"]

[build-dependencies]
rustversion = { workspace = true }

[dev-dependencies]
clap = { version = "4.5", features = ["derive", "env"] }
rand = "0.9.0"
chrono = "0.4.40"
itertools = "0.14.0"

[dependencies]
build_id2 = { workspace = true }
core_affinity2 = { workspace = true }
exceptional = { workspace = true }
fast_rands = { workspace = true }
libafl_core = { workspace = true, features = ["postcard"] }
libafl_derive = { workspace = true, default-features = true, optional = true }
ll_mp = { workspace = true }
minibsod = { workspace = true }
no_std_time = { workspace = true }
ownedref = { workspace = true }
serde_anymap = { workspace = true }
shmem_providers = { workspace = true }
static_assertions = { workspace = true }
tuple_list_ex = { workspace = true, features = ["serde"] }
typeid = { workspace = true }

ahash = { workspace = true, optional = true } # The hash function already used in hashbrown
backtrace = { workspace = true, default-features = true, optional = true } # Used to get the stacktrace in StacktraceObserver
clap = { workspace = true, features = [
  "derive",
  "wrap_help",
], optional = true } # CLI parsing, for libafl_bolts::cli / the `cli` feature
erased-serde = { version = "0.4.5", default-features = false, optional = true } # erased serde
hashbrown = { workspace = true, features = [
  "serde",
  "ahash",
], default-features = false, optional = true } # A faster hashmap, nostd compatible
hostname = { version = "0.4.0", optional = true } # Is there really no gethostname in the stdlib?
log = { workspace = true }
miniz_oxide = { version = "0.8.0", optional = true }
nix = { workspace = true, optional = true, default-features = false, features = [
  "fs",
  "signal",
  "socket",
  "poll",
] }
num_enum = { workspace = true, default-features = false }
postcard = { workspace = true, optional = true } # no_std compatible serde serialization format
pyo3 = { workspace = true, optional = true, features = ["serde", "macros"] }
serde = { workspace = true, default-features = false, features = [
  "derive",
] } # serialization lib
tuple_list = { workspace = true }
uuid = { workspace = true, optional = true, features = ["serde", "v4"] }
xxhash-rust = { version = "0.8.12", features = [
  "xxh3",
], optional = true } # xxh3 hashing for rust

# optional-dev deps (change when target.'cfg(accessible(::std))'.test-dependencies will be stable)
serial_test = { workspace = true, optional = true, default-features = false, features = [
  "logging",
] }

rustversion = { workspace = true }
# optional stable simd, pin to a commit due to `u8x32` not released yet. Switch to `wide` as long as next release is out!
wide = { version = "0.7.33", optional = true, package = "libafl_wide" }

# Document all features of this crate (for `cargo doc`)
document-features = { workspace = true, optional = true }

[target.'cfg(unix)'.dependencies]
libc = { workspace = true }                                            # For (*nix) libc
uds = { version = "0.4.2", optional = true, default-features = false }

[target.'cfg(windows)'.dependencies]
windows = { workspace = true, features = [
  "Win32_Foundation",
  "Win32_Security",
  "Win32_System_Console",
  "Win32_System_Diagnostics_Debug",
  "Win32_System_Kernel",
  "Win32_System_Memory",
  "Win32_System_SystemInformation",
  "Win32_System_Threading",
] }
winapi = { version = "0.3", features = [
  "fileapi",
  "handleapi",
  "processenv",
  "processthreadsapi",
  "winbase",
  "winnt",
] }
windows-result = "0.3.0"

[target.'cfg(windows)'.build-dependencies]
windows = { workspace = true }

[target.'cfg(target_vendor = "apple")'.dependencies]
mach2 = "0.4.2"

#[profile.release]
#lto = true
#opt-level = 3
#debug = true


[[example]]
name = "simd"
path = "./examples/simd/simd.rs"
bench = true
harness = false
required-features = ["std", "simd"]

[lints]
workspace = true
